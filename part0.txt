This is the first part of a multi-part series of blog posts on Micro-services.  There seems to be a lot of ambiguity amongst the community around what these things are, when they should be used and how to approach them.  This blog series is basically a regurgitation of 5 years of building and learning about micro-services.  I imagine that not everybody will agree with everything I say here, but I hope that there is nothing so controversial as to cause serious disagreements. 
 
Over the past 5 years of my career, I seem to have been focusing all of my development and architectural knowledge on a single architectural concept.  It took me a while (almost 3 years) from the first time I delivered a 'Micro-service' architecture to when I actually knew that it should be called a 'Micro-service' architecture.  Basically the architectural concepts just made sense to me and I've delivered 4 production systems that relied heavily on the concepts.  Through that though, I've learnt many things, been burnt many times and finally, after 5 years I think that I can contribute back to the community the things I've learnt over the years. 

The first Micro-service architecture that I was part of building was a tightly coupled system that spanned 5 services to provide, what was essentially a custom build ESB (notable for the very quick build time in relation to using a proper ESB).  Unfortunately, the value of the micro-services was lost based on a lack of infrastructure automation which lead to the service being much more complex than required without the additional benefits one would hope to get.  Learnings? yep. Micro-services? yep. Best architecture? nope.

Another system I worked on was RESTful API for flight prices data.  The data needs for this project were quite complex and nobody was really sure whether the proposed solution would support the API.  Rather than separating the complex data requirements into another service the client chose to keep all the code together in a single service.  When the proposed solution turned out to be insufficient, a large amount of rework was required throughout the codebase to change it.

The next client I worked on had four services running on simple framework in Java.  They were launched in a single JVM.  As the services did not define a bounded context for their domains(2) logic bled between the services and domain logic found its way into the shared client code.  The tightly coupled services did not provide the flexibility or scalability(3) that one would have hoped for from this type of architecture.  From here came the majority of my learnings with regard to this architecture.  It was a great effort towards micro-services, but did not quite hit the nail on the head.

It was after this project that I discovered DropWizard(4), a java framework that glued together a few awesome Java tools.  While we didn't use DropWizard for the project, when I tried to set up SimpleFramework for a Java talk, I was referred to DropWizard and immediately realised how much simpler it was to set up.  20 minutes and I had a RESTful service ready to go!    

I've now taken to DropWizard and am applying this architecture to my current project. We have 5 services that provide our core functionality and a further 3+ services that will provide support functionality (billing, reporting, audit, etc...).  Notably, our frontend service has been implemented twice (once for user testing written in Ruby and the production version written in Java) and is separated from the integration service(5) providing UI flexibility without risking integration bugs (~500 integrating parties will be in the federation). We were able to rewrite our business process service in ~2 weeks with minimal impact on the rest of the system and we are generally able to make substantial changes to the individual services with minimal impact on the rest of the system. All in all, I'd say that micro-services have given us a substantial boost to our flexibility in the face of uncertainty.  Flexibility, though, always comes at a cost.

The lessons I've learnt and the concepts we've applied over the past year are the driver behind this series of blog posts.  While I firmly believe that micro-services are a really good way to build flexible, scalable and performant systems I also accept that there are costs involved in choosing this architecture. This series will be composed of five blog posts that will cover what exactly micro-services are, what to think about when building micro-services, how REST and micro-services relate, some pragmatic thoughts around micro-services, and finally how to test micro-services effectively.

(1) An architecture composing of two tiers, usually datalayer and application layer, that are tightly coupled via remote procedure calls (SOAP, JMI, etc) and should be collapsed into a single tier.
(2) See Domain Driven Design (Eric Evans)
(3) At the time I rolled off the project
(4) http://dropwizard.codahale.com
(5) read at your own risk:  SAML Web SSO Profile 
